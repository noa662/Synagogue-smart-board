"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ZmanimFormatter = void 0;
const luxon_1 = require("luxon");
const Utils_1 = require("../polyfills/Utils");
const Time_1 = require("./Time");
const AstronomicalCalendar_1 = require("../AstronomicalCalendar");
const ZmanimCalendar_1 = require("../ZmanimCalendar");
const ComplexZmanimCalendar_1 = require("../ComplexZmanimCalendar");
const Zman_1 = require("./Zman");
const errors_1 = require("../polyfills/errors");
const methodBlacklist = [
    'getAdjustedDate',
    'getDate',
    'getElevationAdjustedSunrise',
    'getElevationAdjustedSunset',
    'getMidnightLastNight',
    'getMidnightTonight',
    'getSunriseBaalHatanya',
    'getSunsetBaalHatanya',
];
const methodWhitelist = [
    // These methods have parameters, but have default values.
    'getMinchaGedola',
    'getMinchaKetana',
    'getPlagHamincha',
    'getSofZmanKidushLevana15Days',
    'getSofZmanKidushLevanaBetweenMoldos',
    'getSunTransit',
    'getTchilasZmanKidushLevana3Days',
    'getTchilasZmanKidushLevana7Days',
    'getTemporalHour',
];
/**
 * A class used to format both non {@link java.util.Date} times generated by the Zmanim package as well as Dates. For
 * example the {@link AstronomicalCalendar#getTemporalHour()} returns the length of the hour in
 * milliseconds. This class can format this time.
 *
 * @author &copy; Eliyahu Hershfeld 2004 - 2019
 * @version 1.2
 */
class ZmanimFormatter {
    constructor(formatOrTimeZone, dateFormat, timeZoneId) {
        /**
         * Setting to prepend a zero to single digit hours.
         * @see #setSettings(boolean, boolean, boolean)
         */
        this.prependZeroHours = false;
        /**
         * Should seconds be used in formatting time.
         * @see #setSettings(boolean, boolean, boolean)
         */
        this.useSeconds = false;
        /**
         * @see #setSettings(boolean, boolean, boolean)
         */
        this.useMillis = false;
        /**
         * Defaults to {@link #SEXAGESIMAL_XSD_FORMAT}.
         * @see #setTimeFormat(int)
         */
        this.timeFormat = ZmanimFormatter.SEXAGESIMAL_XSD_FORMAT;
        let format;
        if (dateFormat) {
            format = formatOrTimeZone;
        }
        else {
            format = 0;
            dateFormat = 'h:mm:ss';
            timeZoneId = formatOrTimeZone;
        }
        this.setTimeZone(timeZoneId);
        if (this.prependZeroHours) {
            this.hourNF = 2;
        }
        this.setTimeFormat(format);
        this.setDateFormat(dateFormat);
    }
    /**
     * @return the timeZone
     */
    getTimeZone() {
        return this.timeZoneId;
    }
    /**
     * Method to set the TimeZone.
     * @param timeZoneId
     *            the timeZone to set
     */
    setTimeZone(timeZoneId) {
        this.timeZoneId = timeZoneId;
    }
    /**
     * Sets the format to use for formatting.
     *
     * @param format
     *            int the format constant to use.
     */
    setTimeFormat(format) {
        this.timeFormat = format;
        switch (format) {
            case ZmanimFormatter.SEXAGESIMAL_XSD_FORMAT:
                this.setSettings(true, true, true);
                break;
            case ZmanimFormatter.SEXAGESIMAL_FORMAT:
                this.setSettings(false, false, false);
                break;
            case ZmanimFormatter.SEXAGESIMAL_SECONDS_FORMAT:
                this.setSettings(false, true, false);
                break;
            case ZmanimFormatter.SEXAGESIMAL_MILLIS_FORMAT:
                this.setSettings(false, true, true);
                break;
            // case DECIMAL_FORMAT:
            // default:
        }
    }
    /**
     * Sets the SimpleDateFormat Object
     * @param dateFormat the SimpleDateFormat Object to set
     */
    setDateFormat(dateFormat) {
        this.dateFormat = dateFormat;
    }
    /**
     * returns the SimpleDateFormat Object
     * @return the SimpleDateFormat Object
     */
    getDateFormat() {
        return this.dateFormat;
    }
    /**
     * Sets various format settings.
     * @param prependZeroHours  if to prepend a zero for single digit hours (so that 1 o'clock is displayed as 01)
     * @param useSeconds should seconds be used in the time format
     * @param useMillis should milliseconds be used in formatting time.
     */
    setSettings(prependZeroHours, useSeconds, useMillis) {
        this.prependZeroHours = prependZeroHours;
        this.useSeconds = useSeconds;
        this.useMillis = useMillis;
    }
    /**
     * A method that formats milliseconds into a time format.
     *
     * @param milliseconds
     *            The time in milliseconds.
     * @return String The formatted <code>String</code>
     */
    /*
        public format(milliseconds: number): string {
            return this.format(milliseconds);
        }
    */
    /**
     * A method that formats milliseconds into a time format.
     *
     * @param millis
     *            The time in milliseconds.
     * @return String The formatted <code>String</code>
     */
    /*
        public format(millis: number): string {
            return format(new Time(millis));
        }
    */
    /**
     * A method that formats {@link Time} objects.
     *
     * @param time
     *            The time <code>Object</code> to be formatted.
     * @return String The formatted <code>String</code>
     */
    format(timeOrMillis) {
        let time;
        if (timeOrMillis instanceof Time_1.Time) {
            time = timeOrMillis;
        }
        else {
            time = new Time_1.Time(timeOrMillis);
        }
        if (this.timeFormat === ZmanimFormatter.XSD_DURATION_FORMAT) {
            return ZmanimFormatter.formatXSDDurationTime(time);
        }
        let sb = Utils_1.padZeros(time.getHours(), this.hourNF)
            .concat(':')
            .concat(Utils_1.padZeros(time.getMinutes(), ZmanimFormatter.minuteSecondNF));
        if (this.useSeconds) {
            sb = sb.concat(':')
                .concat(Utils_1.padZeros(time.getSeconds(), ZmanimFormatter.minuteSecondNF));
        }
        if (this.useMillis) {
            sb = sb.concat('.')
                .concat(Utils_1.padZeros(time.getMilliseconds(), ZmanimFormatter.milliNF));
        }
        return sb;
    }
    /**
     * Formats a date using this class's {@link #getDateFormat() date format}.
     *
     * @param dateTime - the date to format
     * @return the formatted String
     */
    formatDateTime(dateTime) {
        // eslint-disable-next-line @typescript-eslint/naming-convention
        const _dateTime = dateTime.setZone(this.getTimeZone());
        if (this.dateFormat === ZmanimFormatter.XSD_DATE_FORMAT) {
            return this.getXSDateTime(_dateTime);
        }
        return _dateTime.toFormat(this.dateFormat);
    }
    /**
     * The date:date-time function returns the current date and time as a date/time string. The date/time string that's
     * returned must be a string in the format defined as the lexical representation of xs:dateTime in <a
     * href="http://www.w3.org/TR/xmlschema11-2/#dateTime">[3.3.8 dateTime]</a> of <a
     * href="http://www.w3.org/TR/xmlschema11-2/">[XML Schema 1.1 Part 2: Datatypes]</a>. The date/time format is
     * basically CCYY-MM-DDThh:mm:ss, although implementers should consult <a
     * href="http://www.w3.org/TR/xmlschema11-2/">[XML Schema 1.1 Part 2: Datatypes]</a> and <a
     * href="http://www.iso.ch/markete/8601.pdf">[ISO 8601]</a> for details. The date/time string format must include a
     * time zone, either a Z to indicate Coordinated Universal Time or a + or - followed by the difference between the
     * difference from UTC represented as hh:mm.
     * @param dateTime - the UTC Date Object
     * @return the XSD dateTime
     */
    getXSDateTime(dateTime) {
        return dateTime.setZone(this.getTimeZone())
            .toFormat(ZmanimFormatter.XSD_DATE_FORMAT.concat('ZZ'));
    }
    /**
     * This returns the xml representation of an xsd:duration object.
     *
     * @param millis
     *            the duration in milliseconds
     * @return the xsd:duration formatted String
     */
    /*
        public formatXSDDurationTime(millis: number): string {
            return formatXSDDurationTime(new Time(millis));
        }
    */
    /**
     * This returns the xml representation of an xsd:duration object.
     *
     * @param time
     *            the duration as a Time object
     * @return the xsd:duration formatted String
     */
    static formatXSDDurationTime(timeOrMillis) {
        let time;
        if (timeOrMillis instanceof Time_1.Time) {
            time = timeOrMillis;
        }
        else {
            time = new Time_1.Time(timeOrMillis);
        }
        let duration;
        if (time.getHours() !== 0 || time.getMinutes() !== 0 || time.getSeconds() !== 0 || time.getMilliseconds() !== 0) {
            duration = ('P').concat('T');
            if (time.getHours() !== 0)
                duration = duration.concat(`${time.getHours()}H`);
            if (time.getMinutes() !== 0)
                duration = duration.concat(`${time.getMinutes()}M`);
            if (time.getSeconds() !== 0 || time.getMilliseconds() !== 0) {
                duration = duration.concat(`${time.getSeconds()}.${Utils_1.padZeros(time.getMilliseconds(), ZmanimFormatter.milliNF)}`);
                duration = duration.concat('S');
            }
            if (duration.length === 1)
                duration.concat('T0S'); // zero seconds
            if (time.isNegative()) {
                duration = duration.substr(0, 0).concat('-').concat(duration.substr(0, duration.length));
            }
        }
        return duration.toString();
    }
    static formatDecimal(num) {
        const hasDecimal = num - Math.trunc(num) > 0;
        return hasDecimal ? num.toString() : num.toFixed(1);
    }
    /**
     * A method that returns an XML formatted <code>String</code> representing the serialized <code>Object</code>. The
     * format used is:
     *
     * <pre>
     *  &lt;AstronomicalTimes date=&quot;1969-02-08&quot; type=&quot;AstronomicalCalendar algorithm=&quot;US Naval Almanac Algorithm&quot; location=&quot;Lakewood, NJ&quot; latitude=&quot;40.095965&quot; longitude=&quot;-74.22213&quot; elevation=&quot;31.0&quot; timeZoneName=&quot;Eastern Standard Time&quot; timeZoneID=&quot;America/New_York&quot; timeZoneOffset=&quot;-5&quot;&gt;
     *     &lt;Sunrise&gt;2007-02-18T06:45:27-05:00&lt;/Sunrise&gt;
     *     &lt;TemporalHour&gt;PT54M17.529S&lt;/TemporalHour&gt;
     *     ...
     *   &lt;/AstronomicalTimes&gt;
     * </pre>
     *
     * Note that the output uses the <a href="http://www.w3.org/TR/xmlschema11-2/#dateTime">xsd:dateTime</a> format for
     * times such as sunrise, and <a href="http://www.w3.org/TR/xmlschema11-2/#duration">xsd:duration</a> format for
     * times that are a duration such as the length of a
     * {@link AstronomicalCalendar#getTemporalHour() temporal hour}. The output of this method is
     * returned by the {@link #toString() toString}.
     *
     * @param astronomicalCalendar the AstronomicalCalendar Object
     *
     * @return The XML formatted <code>String</code>. The format will be:
     *
     *         <pre>
     *  &lt;AstronomicalTimes date=&quot;1969-02-08&quot; type=&quot;AstronomicalCalendar algorithm=&quot;US Naval Almanac Algorithm&quot; location=&quot;Lakewood, NJ&quot; latitude=&quot;40.095965&quot; longitude=&quot;-74.22213&quot; elevation=&quot;31.0&quot; timeZoneName=&quot;Eastern Standard Time&quot; timeZoneID=&quot;America/New_York&quot; timeZoneOffset=&quot;-5&quot;&gt;
     *     &lt;Sunrise&gt;2007-02-18T06:45:27-05:00&lt;/Sunrise&gt;
     *     &lt;TemporalHour&gt;PT54M17.529S&lt;/TemporalHour&gt;
     *     ...
     *  &lt;/AstronomicalTimes&gt;
     * </pre>
     *
     *         TODO: add proper schema, and support for nulls. XSD duration (for solar hours), should probably return
     *         nil and not P
     * @deprecated
     */
    static toXML() {
        throw new errors_1.UnsupportedError('This method is not supported.');
    }
    /**
     * A method that returns a JSON formatted <code>String</code> representing the serialized <code>Object</code>. The
     * format used is:
     * <pre>
     * {
     *    &quot;metadata&quot;:{
     *      &quot;date&quot;:&quot;1969-02-08&quot;,
     *      &quot;type&quot;:&quot;AstronomicalCalendar&quot;,
     *      &quot;algorithm&quot;:&quot;US Naval Almanac Algorithm&quot;,
     *      &quot;location&quot;:&quot;Lakewood, NJ&quot;,
     *      &quot;latitude&quot;:&quot;40.095965&quot;,
     *      &quot;longitude&quot;:&quot;-74.22213&quot;,
     *      &quot;elevation:&quot;31.0&quot;,
     *      &quot;timeZoneName&quot;:&quot;Eastern Standard Time&quot;,
     *      &quot;timeZoneID&quot;:&quot;America/New_York&quot;,
     *      &quot;timeZoneOffset&quot;:&quot;-5&quot;},
     *    &quot;AstronomicalTimes&quot;:{
     *     &quot;Sunrise&quot;:&quot;2007-02-18T06:45:27-05:00&quot;,
     *     &quot;TemporalHour&quot;:&quot;PT54M17.529S&quot;
     *     ...
     *     }
     * }
     * </pre>
     *
     * Note that the output uses the <a href="http://www.w3.org/TR/xmlschema11-2/#dateTime">xsd:dateTime</a> format for
     * times such as sunrise, and <a href="http://www.w3.org/TR/xmlschema11-2/#duration">xsd:duration</a> format for
     * times that are a duration such as the length of a
     * {@link AstronomicalCalendar#getTemporalHour() temporal hour}.
     *
     * @param astronomicalCalendar the AstronomicalCalendar Object
     *
     * @return The JSON formatted <code>String</code>. The format will be:
     * <pre>
     * {
     *    &quot;metadata&quot;:{
     *      &quot;date&quot;:&quot;1969-02-08&quot;,
     *      &quot;type&quot;:&quot;AstronomicalCalendar&quot;,
     *      &quot;algorithm&quot;:&quot;US Naval Almanac Algorithm&quot;,
     *      &quot;location&quot;:&quot;Lakewood, NJ&quot;,
     *      &quot;latitude&quot;:&quot;40.095965&quot;,
     *      &quot;longitude&quot;:&quot;-74.22213&quot;,
     *      &quot;elevation:&quot;31.0&quot;,
     *      &quot;timeZoneName&quot;:&quot;Eastern Standard Time&quot;,
     *      &quot;timeZoneID&quot;:&quot;America/New_York&quot;,
     *      &quot;timeZoneOffset&quot;:&quot;-5&quot;},
     *    &quot;AstronomicalTimes&quot;:{
     *     &quot;Sunrise&quot;:&quot;2007-02-18T06:45:27-05:00&quot;,
     *     &quot;TemporalHour&quot;:&quot;PT54M17.529S&quot;
     *     ...
     *     }
     * }
     * </pre>
     */
    static toJSON(astronomicalCalendar) {
        const json = {
            metadata: ZmanimFormatter.getOutputMetadata(astronomicalCalendar),
        };
        const key = ZmanimFormatter.getOutputKey(astronomicalCalendar);
        json[key] = ZmanimFormatter.getZmanimOutput(astronomicalCalendar);
        return json;
    }
    // @ts-ignore
    static getOutputKey(astronomicalCalendar) {
        switch (true) {
            case astronomicalCalendar instanceof ComplexZmanimCalendar_1.ComplexZmanimCalendar:
                return 'Zmanim';
            case astronomicalCalendar instanceof ZmanimCalendar_1.ZmanimCalendar:
                return 'BasicZmanim';
            case astronomicalCalendar instanceof AstronomicalCalendar_1.AstronomicalCalendar:
                return 'AstronomicalTimes';
        }
    }
    static getOutputMetadata(astronomicalCalendar) {
        const df = 'yyyy-MM-dd';
        return {
            date: astronomicalCalendar.getDate().toFormat(df),
            type: astronomicalCalendar.getClassName(),
            algorithm: astronomicalCalendar.getAstronomicalCalculator().getCalculatorName(),
            location: astronomicalCalendar.getGeoLocation().getLocationName(),
            latitude: astronomicalCalendar.getGeoLocation().getLatitude().toString(),
            longitude: astronomicalCalendar.getGeoLocation().getLongitude().toString(),
            elevation: ZmanimFormatter.formatDecimal(astronomicalCalendar.getGeoLocation().getElevation()),
            timeZoneName: Utils_1.TimeZone.getDisplayName(astronomicalCalendar.getGeoLocation().getTimeZone(), astronomicalCalendar.getDate()),
            timeZoneID: astronomicalCalendar.getGeoLocation().getTimeZone(),
            timeZoneOffset: ZmanimFormatter.formatDecimal(Utils_1.TimeZone.getOffset(astronomicalCalendar.getGeoLocation().getTimeZone(), astronomicalCalendar.getDate().valueOf()) / ZmanimFormatter.HOUR_MILLIS),
        };
    }
    static getZmanimOutput(astronomicalCalendar) {
        const formatter = new ZmanimFormatter(ZmanimFormatter.XSD_DURATION_FORMAT, ZmanimFormatter.XSD_DATE_FORMAT, astronomicalCalendar.getGeoLocation().getTimeZone());
        const dateList = [];
        let durationList = [];
        const otherList = [];
        // Get al the methods in the calendar
        Utils_1.Utils.getAllMethodNames(astronomicalCalendar, true)
            // Filter out methods that we don't want
            .filter(method => includeMethod(method, astronomicalCalendar))
            // Call each method and get the return values
            .map(method => ({
            methodName: method,
            value: astronomicalCalendar[method].call(astronomicalCalendar),
        }))
            // Filter for return values of type Date or number
            .filter(methodObj => luxon_1.DateTime.isDateTime(methodObj.value) || typeof methodObj.value === 'number' || methodObj.value === null)
            // Separate the Dates and numbers
            .forEach(methodObj => {
            const tagName = methodObj.methodName.substring(3);
            if (luxon_1.DateTime.isDateTime(methodObj.value)) {
                dateList.push(new Zman_1.Zman(methodObj.value, tagName));
            }
            else if (typeof methodObj.value === 'number') {
                durationList.push(new Zman_1.Zman(methodObj.value, tagName));
            }
            else {
                otherList.push(tagName);
            }
        });
        dateList.sort(Zman_1.Zman.compareDateOrder);
        // Filter for values in milliseconds, and not values in minutes
        durationList = durationList.filter((zman) => zman.duration > 1000)
            .sort(Zman_1.Zman.compareDurationOrder);
        const timesData = {};
        dateList.forEach((zman) => {
            timesData[zman.label] = formatter.formatDateTime(zman.zman);
        });
        durationList.forEach((zman) => {
            timesData[zman.label] = formatter.format(Math.trunc(zman.duration));
        });
        otherList.forEach((tagName) => {
            timesData[tagName] = 'N/A';
        });
        return timesData;
    }
}
exports.ZmanimFormatter = ZmanimFormatter;
/**
 * the formatter for minutes as seconds.
 */
ZmanimFormatter.minuteSecondNF = 2;
/**
 * the formatter for minutes as milliseconds.
 */
ZmanimFormatter.milliNF = 3;
/**
 * Format using hours, minutes, seconds and milliseconds using the xsd:time format. This format will return
 * 00.00.00.0 when formatting 0.
 */
ZmanimFormatter.SEXAGESIMAL_XSD_FORMAT = 0;
/**
 * Format using standard decimal format with 5 positions after the decimal.
 */
ZmanimFormatter.DECIMAL_FORMAT = 1;
/** Format using hours and minutes. */
ZmanimFormatter.SEXAGESIMAL_FORMAT = 2;
/** Format using hours, minutes and seconds. */
ZmanimFormatter.SEXAGESIMAL_SECONDS_FORMAT = 3;
/** Format using hours, minutes, seconds and milliseconds. */
ZmanimFormatter.SEXAGESIMAL_MILLIS_FORMAT = 4;
/** constant for milliseconds in a minute (60,000) */
ZmanimFormatter.MINUTE_MILLIS = 60 * 1000;
/** constant for milliseconds in an hour (3,600,000) */
ZmanimFormatter.HOUR_MILLIS = ZmanimFormatter.MINUTE_MILLIS * 60;
/**
 * Format using the XSD Duration format. This is in the format of PT1H6M7.869S (P for period (duration), T for time,
 * H, M and S indicate hours, minutes and seconds.
 */
ZmanimFormatter.XSD_DURATION_FORMAT = 5;
ZmanimFormatter.XSD_DATE_FORMAT = 'yyyy-LL-dd\'T\'HH:mm:ss';
/**
 * Determines if a method should be output by the {@link #toJSON(AstronomicalCalendar)}
 *
 * @param {string} method - the method in question
 * @param {AstronomicalCalendar} astronomicalCalendar - The astronomical calendar, to be able to
 * check the parameterlist
 * @return if the method should be included in serialization
 */
function includeMethod(method, astronomicalCalendar) {
    if (methodWhitelist.includes(method))
        return true;
    // Filter out excluded methods
    return !methodBlacklist.includes(method)
        // Filter out methods with parameters since we don't know what value(s) to pass
        && astronomicalCalendar[method].length === 0
        // Filter out methods that don't start with 'get'
        && method.startsWith('get');
}
//# sourceMappingURL=ZmanimFormatter.js.map